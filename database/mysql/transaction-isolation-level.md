# 数据库事务隔离级别

数据库并发事务导致的问题，总结来说其中两类是更新问题，三类是读问题，数据库是如何避免这种并发事务问题的呢？答案就是通过不同的事务隔离级别，在不同的隔离级别下，并发事务读取数据的结果是不一样的。我们需要根据业务的要求，设置不同的隔离级别，在效率和数据安全性中找到平衡点。 SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

### **SERIALIZABLE**

* **串行化**
* 当数据库系统使用SERIALIZABLE隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是串行化方式运行。

### **REPEATABLE READ**

* **可重复读**
* 当数据库系统使用REPEATABLE READ隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。

### **READ COMMITTED**

* **读已提交数据**
* 当数据库系统使用READ COMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且还能看到其他事务已经提交的对已有记录的更新。

### **READ UNCOMMITTED**

* **读未提交数据**
* 当数据库系统使用READ UNCOMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。

以上的四种隔离级别按从高到底排序，你可能会说，选择SERIALIZABLE，因为它最安全！没错，它是最安全，但它也是最慢的！四种隔离级别的安全性与性能成反比！最安全的性能最差，最不安全的性能最好！  


#### 隔离级别与并发问题

| 隔离级别 | 第一类丢失更新 | 第二类丢失更新 | 脏读 | 不可重复读 | 幻读 |
| :--- | :--- | :--- | :--- | :--- | :--- |
| SERIALIZABLE | 避免 | 避免 | 避免 | 避免 | 避免 |
| REPEATABLE READ | 避免 | 避免 | 避免 | 避免 | 允许 |
| READ COMMITTED | 避免 | 允许 | 避免 | 允许 | 允许 |
| READ UNCOMMITTED | 避免 | 允许 | 允许 | 允许 | 允许 |



**参考资料：**

* [数据库事务隔离级](https://juejin.im/post/6844903670916579336)

