# 事务

事务（Transaction）是并发控制的基本单位。**所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。**例如，银行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要么都不执行。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。

我们以Msql数据库的操作为例，再进一步解释一下数据库事务： 首先我们用以下命令查看该Mysql会话的事务隔离级别，关于事务隔离级别及其作用，我们在后面的章节中会进行详细介绍，这里只要简单知道数据库可以设置不同的事务隔离级别，不同的隔离级别会对事务的操作产生不同的效果即可。使用以下命令可以查询当前Mysql会话的事务隔离级别，可以看到，Mysql默认的事务隔离级别是REPEATABLE-READ。

```bash
mysql> select @@tx_isolation;
+-----------------+
| @@tx_isolation  |
+-----------------+
| REPEATABLE-READ |
+-----------------+
```

为了用实例来解释事务，我们创建了如下的bank数据表，并插入一条数据，

```bash
mysql> describe bank;
+---------+---------------+------+-----+---------+----------------+
| Field   | Type          | Null | Key | Default | Extra          |
+---------+---------------+------+-----+---------+----------------+
| id      | int(11)       | NO   | PRI | NULL    | auto_increment |
| name    | varchar(40)   | NO   |     | NULL    |                |
| balance | decimal(10,2) | YES  |     | NULL    |                |
+---------+---------------+------+-----+---------+----------------+

mysql> select * from bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  3 | fufu | 2000.00 |
+----+------+---------+
```

使用start transaction命令开启数据库事务，

```bash
mysql> start transaction;
Query OK, 0 rows affected (0.00 sec)
```

更新id为3的行的balance值为3000.00，

```bash
mysql> update bank set balance = 3000 where id = 3;
Query OK, 1 row affected (0.09 sec)
Rows matched: 1  Changed: 1  Warnings: 0

mysql> select * from bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  3 | fufu | 3000.00 |
+----+------+---------+
1 row in set (0.00 sec)
```

此时我们可以看到，select语句查询到的id为3的行的balance值已经修改为3000.00，接下来我们再尝试插入一条新数据，

```bash
mysql> insert into bank (name, balance) values ('melo', 1000);
Query OK, 1 row affected (0.06 sec)

mysql> select * from bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  3 | fufu | 3000.00 |
|  4 | melo | 1000.00 |
+----+------+---------+
2 rows in set (0.00 sec)
```

由于以上的update和insert操作都是**在start transaction命令开启事务之后，所以直到事务结束，这些操作都属于同一事务**，假设我们在insert操作时产生了错误，可以根据事务的定义得知，这些属于同一事务的所有操作要么都执行要么都不执行，我们可以验证一下，使用rollback命令，模拟事务失败回滚，

```bash
mysql> rollback;
Query OK, 0 rows affected (0.01 sec)
```

此时我们在查询数据库中的所有数据，发现数据恢复到了update命令执行前的状态，id为3的行的balance值等于2000没有变化。

```bash
mysql> select * from bank;
+----+------+---------+
| id | name | balance |
+----+------+---------+
|  3 | fufu | 2000.00 |
+----+------+---------+
1 row in set (0.00 sec)
```

到此，我们阐述了数据库事务的定义并用简单的Mysql操作说明了事务的操作方式，我们可以总结出数据库事务的生命周期如下：  
![](https://user-gold-cdn.xitu.io/2018/9/6/165ad9f0d6d6b87b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1) 

可以看出事务的边界包括：

* 事务的开始边界
* 事务的正常结束边界（COMMIT），提交事务，永久保存被事务更新后的数据库状态。
* 事务的异常结束边界（ROLLBACK）：撤销事务，使数据库退回到执行事务前的初始状态。

现在我们回过头来思考一下上述示例，示例中的所有操作都是在一个Mysql会话中进行的，也就是没有其他用户在同时连接数据库进行操作，在这种没有并发会话的使用场景中，无论事务是正常结束还是异常结束，对于该单独用户读取数据不会造成任何影响，因为他的所有操作都是串行的。但是在实际应用场景中，数据库每时每刻都服务于很多会话，假设用户A的事务A开始后更新了数据库数据，此时用户B开始读取该数据，用户B将会读取到了新的值。但是如果紧接着事务A在下一条SQL语句操作时产生了错误，将事务A回滚了，那么用户B读取到的数据就是错误的无效数据了。这只是数据库事务在并发环境下会产生的一个简单的问题，所以接下来详细阐述并发事务会产生的问题。

## 并发事务会产生的问题

###  **丢失更新**

#### **第一类丢失更新**

定义：A事务撤销时，把已经提交的B事务的更新数据覆盖了。

| 时间点 | 事务A | 事务B |
| :--- | :--- | :--- |
| **T1** | **开始事务** | \*\*\*\* |
| **T2** | \*\*\*\* | **开始事务** |
| **T3** | 查询账户余额为1000元 | \*\*\*\* |
| **T4** | \*\*\*\* | 查询账户余额为1000元 |
| **T5** | \*\*\*\* | 存入100元把余额改为1100元 |
| **T6** | \*\*\*\* | **提交事务** |
| **T7** | 取出100元把余额改为900元 | \*\*\*\* |
| **T8** | **撤销事务** | \*\*\*\* |
| **T9** | 余额恢复为1000元（丢失更新） | \*\*\*\* |

以上的示例演示了第一类丢失更新问题，事务B虽然成功了，但是它所做的更新没有被永久存储，这种并发问题是由于完全没有隔离事务造成的。当两个事务更新相同的数据时，如果一个事务被提交，另一个事务却撤销，那么会连同第一个事务所做的更新也被撤销了。（这是绝对避免出现的事情） 事务A的开始时间和结束时间包含事务B的开始和结束时间,事务A回滚事务的同时,把B的已经提交的事务也回滚的,这是避免的,这就是第一类丢失更新.

  


**参考资料：**

* [数据库事务隔离级别](https://juejin.im/post/6844903670916579336)

