# JVM结构

JVM主要包括四个部分

* 类加载器：在JVM启动时或者在类运行时将需要的class加载到JVM中。
* 执行引擎：负责执行class文件中包含的字节码指令。
* 内存区\(运行时数据区\)：是在JVM运行的时候操作所分配的内存区。
  * 可以划分为5个区域:
    * `方法区(Method Area)`：
      * 用于存储类结构信息的地方，包括常量池、静态变量、构造函数等。
      * JVM规范把方法区描述为堆的一个逻辑部分， 但它却有个别名non-heap。
      * 方法区与堆有很多共性：线程共享、内存不连续、可扩展、可垃圾回收，同样当无法再扩展时会抛出`OutOfMemoryError`异常。
      * 方法区的内存回收目标主要是针对常量池的回收和对类型的卸载。
      * `运行时常量池`是方法区的一部分，`class`文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池用于存放编译期生成的各种字面量和符号引用，这部分在类加载后进入方法区的运行是常量池中，如String类的`intern()`方法。
    * `java堆(Heap)`：
      * 堆内存最大
      * 存储java实例或者对象的地方。
      * Heap是伴随着JVM的启动而创建，负责存储所有对象实例和数组的。
      * 堆的存储空间是不需要连续的。
    * `java栈(Stack)`：
      * 每当创建一个线程时，JVM就会为这个线程创建一个对应的java栈。
      * 会包含多个栈帧，每运行一个方法就创建一个栈帧。
      * 每个栈帧存的数据：
        * `局部变量`：用于存放方法参数和方法内定义的局部变量。
        * `操作数栈`：随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。
        * `动态链接`：每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的动态链接。
        * `方法返回地址`：无论方法是否正常完成，都需要返回到方法被调用的位置，程序才能继续进行。
      * 每一个方法从调用直至执行完成的过程，就对应一个栈帧在Java栈中入栈到出栈的过程。
      * 栈的内存地址是不连续的。
      * 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常
      * 如果虚拟机栈动态扩展时无法申请到足够的内存时会抛出`OutOfMemoryError`异常。
    * `程序计数器(PC Register)`：
      * 用于保存当前线程执行的内存地址。
      * 由于JVM程序是多线程执行的\(线程轮流切换\)，所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方。
      * 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    * `本地方法栈(Native Method Stack)`：和java栈的作用差不多，只不过是为JVM使用到的native方法服务的。
  * 线程共享的区域：`方法区`、`java堆`
  * 线程私有的区域：`java栈`、`程序计数器`、`本地方法栈`
* 本地方法接口：主要是调用C或C++实现的本地方法及返回结果。

