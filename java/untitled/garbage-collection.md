# 垃圾回收

## 垃圾检测

* `引用计数法`：给一个对象添加引用计数器，每当有个地方引用它，计数器就加1，引用失效就减1。
  * 两个对象互相引用，除此之外没有其他任何对象引用它们，实际上这两个对象已经无法访问，但计数不为0，导致无法回收。
* `可达性分析算法`：以根集对象为起始点进行搜索，如果有对象不可达的话，即是垃圾对象。这里的根集一般包括java栈中引用的对象、方法区常良池中引用的对象。

## 回收算法

* `标记-清除`：标记所有需要回收的对象，然后统一回收。
  * 效率低；标记清除之后会产生大量碎片。
* `复制`：此算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。此算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现碎片问题。
  * 需要两倍内存空间。
* `标记-整理`：第一阶段从根节点开始标记所有被引用对象；第二阶段遍历整个堆，把清除未标记对象并且把存活对象压缩到堆的其中一块，按顺序排放。
  * 此算法避免了`标记-清除`算法的碎片问题，同时也避免了`复制`算法的空间问题。
* `分代收集算法`
  * 基于：不同的对象的生命周期是不一样的，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。
  * 将对象按其生命周期的不同划分成：`年轻代(Young Generation)`、`年老代(Old Generation)`、`持久代(Permanent Generation)`。
  * `持久代`主要存放的是类信息，所以与Java对象的回收关系不大，与回收息息相关的是`年轻代`和`年老代`。
  * `年轻代`
    * 分3个区：
      * 一个`Enden`区
      * 两个`Survivor`区
        * `from`
        * `to`
        * `from`和`to`是相对的
    * 使用`复制`算法
    * 当`Eden`区被对象填满时，就会执行`Minor GC`。
      * `Minor GC`: 把所有存活下来的对象转移到其中一个`survivor`区\(假设为`from`区\)；同时会检查`survivor`区存活下来的对象，并把它们转移到另一个`survivor`区\(假设为`to`区\)；保证了在一段时间内，总有一个`survivor`区是空的。
    * 经过多次GC周期后，仍然存活下来的对象会被转移到`年老代`内存空间。具体经过几次GC才转移，可以通过年龄阈值来完成设定的。
  * `年老代`
    * 通常会在老年代内存被占满时将会触发`Full GC`，回收整个堆内存。
    * 使用`标记-整理`算法
  * `持久代`：用于存放静态文件，比如java类、方法等，持久代对垃圾回收没有显著的影响。

## 垃圾收集器

* `新生代`收集器
  * `Serial`收集器
    * 单线程执行。
    * 使用`复制`算法。
    * 在进行垃圾收集时，必须暂停其他所有的工作线程。
    * `JVM client`模式下默认的新生代收集器。
    * 对于限定单个CPU的环境来说，`Serial`收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
  * `ParNew`收集器
    * `ParNew`收集器其实就是`serial`收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为与`Serial`收集器一样。
  * `Parallel Scavenge`收集器
    * 使用`复制`算法。
    * 并行多线程。
    * 目标是达到一个可控制的吞吐量
      * `吞吐量 = 程序运行时间 / (程序运行时间 + 垃圾收集时间)`
* `老年代`收集器
  * `Serial Old`收集器
    * `Serial`收集器的老年代版本。
    * 使用`标记-整理`算法。
    * 主要使用在`JVM client`模式下的虚拟机。
  * `Parallel Old`收集器
    * `Parallel Scavenge`收集器的老年代版本。
    * 使用多线程和`标记-整理`算法。 
  * `CMS(Concurrent Mark Sweep)`收集器
    * 以获取最短回收停顿时间为目标。
    * 基于`标记-清除`算法
    * 分为4个步骤：
      * `初始标记(CMS initial mark)`：只是标记出GC ROOTS能直接关联到的对象，速度很快，并发标记阶段是进行GC ROOTS 根搜索算法阶段，会判定对象是否存活。
      * `并发标记(CMS concurrenr mark)`
      * `重新标记(CMS remark)`：修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会被初始标记阶段稍长，但比并发标记阶段要短。
      * `并发清除(CMS concurrent sweep)`
    * 其中`初始标记`、`重新标记`这两个步骤任然需要停顿其他用户线程。
    * `并发标记`和`并发清除`过程中，收集器线程都可以与用户线程一起工作。
* `G1`收集器
  * `JDK1.7`提供的一个新收集器
  * 基于`标记-整理`算法
  * 收集的范围都是整个新生代或老年代

