# final关键字

`final`可以修饰`变量`、`方法`和`类`，用于表示所修饰的内容一旦赋值之后就不会再被改变

* 变量
  * `final`成员变量
    * `类变量`
      * 可以在`声明变量的时候`直接赋初值，或者在`静态代码块`中给类变量赋初值。
    * `实例变量`
      * 可以在`声明变量的时候`给实例变量赋初值，在`非静态初始化块`中以及`构造器`中赋初值。
    * 当`final`变量未初始化时系统不会进行隐式初始化，会出现报错。 
  * `final`局部变量
    * 需要显式初始化。
    * 如果`final`局部变量已经进行了初始化则后面就不能再次进行更改。
    * 如果`final`变量未进行初始化，可以进行赋值，当且仅有一次赋值。
  * `final`基本数据类型 vs `final`引用数据类型
    * 当`final`修饰基本数据类型变量时，不能对基本数据类型变量重新赋值，因此基本数据类型变量不能被改变。
    * 而对于引用类型变量而言，它仅仅保存的是一个引用，`final`只保证这个引用类型变量所引用的地址不会发生改变，即一直引用这个对象，但这个对象属性是可以改变的。
  * 宏变量
    * 使用`final`修饰符修饰。
    * 在定义该`final`变量时就指定了初始值。
    * 该初始值在编译时就能够唯一指定。
* 方法
  * 父类的`final`方法是不能够被子类重写的
  * `final`方法是可以被重载的
* 类
  * 当一个类被`final`修饰时，表名该类是不能被子类继承的。

## 多线程中的final

`final`域重排序规则

* 写`final`域重排序规则
  * JMM禁止编译器把`final`域的写重排序到构造函数之外。
  * 编译器会在`final`域写之后，构造函数返回之前，插入一个`storestore`屏障
* 读`final`域重排序规则
  * 在一个线程中，初次读对象引用和初次读该对象包含的`final`域，JMM会禁止这两个操作的重排序。
  * 处理器会在读`final`域操作的前面插入一个`LoadLoad`屏障。
  * 确保在读一个对象的`final`域之前，一定会先读这个包含这个`final`域的对象的引用。

`final`域为引用类型

* 针对引用数据类型，`final`域写针对编译器和处理器重排序增加了这样的约束：
  * 在构造函数内对一个`final`修饰的对象的成员域的写入，与随后在构造函数之外把这个被构造的对象的引用赋给一个引用变量，这两个操作是不能被重排序的。

## final的实现原理

* 写`final`域会要求编译器在`final`域写之后，构造函数返回前插入一个`StoreStore`屏障。读`final`域的重排序规则会要求编译器在读`final`域的操作前插入一个`LoadLoad`屏障。

