# Java内存模型

当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那这个对象是`线程安全`的。

* 出现线程安全的问题一般是因为`主内存和工作内存数据不一致性`和`重排序`导致的。
* 当多个线程相互协作完成一件事情，会涉及到多个线程会间相互通信告知彼此的状态以及当前的执行结果等。
* 线程间通信是指线程之间以何种机制来交换信息，主要有两种：
  * `共享内存`：
    * 线程之间主要通过`读-写共享变量`来完成隐式通信。
    * 共享变量：所有放在堆内存中的`实例域`，`静态域`和`数组`元素
    * 共享数据会出现线程安全的问题，而非共享数据不会出现线程安全的问题。
  * `消息传递`
* 共享变量的写入流程
  * `共享变量`会先放在`主内存`中，每个线程都有属于自己的`工作内存`，并且会把位于主内存中的共享变量拷贝到自己的工作内存，之后的读写操作均使用位于工作内存的变量副本，并在某个时刻将工作内存的变量副本写回到主存中去。
  * `线程A`和`线程B`之间要通过`共享内存`完成通信的话，要经历如下两步：
    * `线程A`从主内存中将共享变量读入`线程A`的工作内存后并进行操作，之后将数据重新写回到主内存中。
    * `线程B`从主内存中读取最新的共享变量。
  * `线程A`和`线程B`就好像通过共享变量在进行`隐式通信`。
  * 如果`线程A`更新后数据并没有及时写回到主存，而此时`线程B`读到的是过期的数据，这就出现了“脏读”现象。
  * 可以通过`同步机制`来解决，或者通过`volatile`关键字使得每次`volatile`变量都能够强制刷新到主存，从而对每个线程都是可见的。

