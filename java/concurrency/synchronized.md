# synchronized关键字

`Synchronized`使用场景

| 分类 | 具体分类 | 被锁的对象 | 伪代码 |
| :--- | :--- | :--- | :--- |
| 方法 | 实例方法 | 类的实例对象 | `public synchronized void method() { ... }` |
| 方法 | 静态方法 | 类对象 | `public static synchronized void method() { ... }` |
| 代码块 | 实例对象 | 类的实例对象 | `synchronized(this) { ... }` |
| 代码块 | class对象 | 类对象 | `synchronized(SynchronizedDemo.class) { ... }` |
| 代码块 | 任意实例对象Object | 实例对象Object | `String lock = ""; synchronized(lock) { ... }` |

* `实例方法`和`静态方法`分别锁的是该类的`实例对象`和`该类的对象`。
* 如果锁的是类对象的话，尽管new多个实例对象，但他们仍然是属于同一个类依然会被锁住，即线程之间保证同步关系。

## 对象锁机制

对象锁 = `monitor`

* 执行同步代码块后首先要先执行`monitorenter`指令，退出的时候`monitorexit`指令。
* 使用`Synchronized`进行同步，其关键就是必须要对对象的监视器`monitor`进行获取，当线程获取`monitor`后才能继续往下执行，否则就只能等待。而这个获取的过程是`互斥`的，即同一时刻只有一个线程能够获取到`monitor`。
* `锁的重入性`：即在同一锁程中，线程不需要再次获取同一把锁，`Synchronized`先天具有重入性。
* 每个对象拥有一个计数器，当线程获取该对象锁后，计数器就会加一，释放锁后就会将计数器减一。
* 任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取该对象的监视器才能进入同步块和同步方法，如果没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入到`BLOCKED`状态，当对象的监视器占有者释放后，在同步队列中得线程就会有机会重新获取该监视器。

## synchronized优化

由于`Synchronized`是互斥的，每次只能通过一个线程，效率比较低。

### CAS操作

`Compare And Swap`

使用锁时，线程获取锁是一种`悲观锁`策略，即假设每一次执行临界区代码都会产生冲突。

`CAS`操作\(又称为无锁操作\)是一种`乐观锁`策略，它假设所有线程访问共享资源的时候不会出现冲突。

`CAS`的操作过程

* `CAS`比较交换的过程可以通俗的理解为`CAS(V,O,N)`，包含三个值分别为：
  * `V`内存地址存放的实际值
  * `O`预期的值\(旧值\)
  * `N`更新的新值
* 当`V`和`O`相同时，也就是说旧值和内存中实际的值相同表明该值没有被其他线程更改过，即该旧值`O`就是目前来说最新的值了，自然而然可以将新值`N`赋值给`V`。
* 反之，`V`和`O`不相同，表明该值已经被其他线程改过了则该旧值`O`不是最新版本的值了，所以不能将新值`N`赋给`V`，返回`V`即可。
* 当多个线程使用`CAS`操作一个变量是，只有一个线程会成功，并成功更新，其余会失败。失败的线程会重新尝试，当然也可以选择挂起线程。

`CAS`的实现需要硬件指令集的支撑，在JDK1.5后虚拟机才可以使用处理器提供的`CMPXCHG`指令实现。

`CAS`的应用场景：`J.U.C(java.util.concurrent)`包中使用`CAS`的实现类有很多，可以说是支撑起整个`concurrency`包的实现，在`Lock`实现中会有`CAS`改变`state`变量，在`atomic`包中的实现类也几乎都是用`CAS`实现。

`CAS`的问题

* ABA问题
  * `CAS`会检查旧值有没有变化。一个旧值A变为了成B，然后再变成A，刚好在做`CAS`时检查发现旧值并没有变化依然为A，但是实际上的确发生了变化。添加一个版本号可以解决，原来的变化路径`A->B->A`就变成了`1A->2B->3C`。
    * 自旋时间过长
  * 使用`CAS`时非阻塞同步，也就是说不会将线程挂起，会自旋\(无非就是一个死循环\)进行下一次尝试，如果这里自旋时间过长对性能是很大的消耗。如果JVM能支持处理器提供的`pause`指令，那么在效率上会有一定的提升。
    * 只能保证一个共享变量的原子操作
  * 当对一个共享变量执行操作时`CAS`能保证其原子性，如果对多个共享变量进行操作，`CAS`就不能保证其原子性。有一个解决方案是利用对象整合多个共享变量，即一个类中的成员变量就是这几个共享变量。然后将这个对象做`CAS`操作就可以保证其原子性。

### Java对象头

对象的锁就是类似对对象的一个标志，那么这个标志就是存放在Java对象的对象头。

Java对象头里存了一个32位的Mark Word，默认存储结构为：

* 锁状态
* 对象的Hashcode\(`25 bits`\)
* 对象分代年龄\(`4 bits`\)
* 是否是偏向锁\(`1 bit`\)
* 锁标志位\(`2 bits`\)

锁一共有4种状态，级别从低到高依次是：

* `无锁状态`
* `偏向锁状态`
* `轻量级锁状态`
* `重量级锁状态`

这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

### 偏向锁

大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了`偏向锁`。

`偏向锁`的获取：

* 对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行`CAS`操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的`偏向锁`。
* 如果测试成功，表示线程已经获得了锁。
* 如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1，表示当前是`偏向锁`。
* 如果没有设置，则使用`CAS`竞争锁。
* 如果设置了，则尝试使用`CAS`将对象头的`偏向锁`指向当前线程。

`偏向锁`的撤销

* `偏向锁`使用了一种等到竞争出现才释放锁的机制。
* 撤销需要等待全局安全点，在这个时间点上没有正在执行的字节码。
* 首先暂停拥有`偏向锁`的线程，然后检查持有`偏向锁`的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态。
* 如果线程仍然活着，拥有`偏向锁`的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为`偏向锁`，最后唤醒暂停的线程。

### 轻量级锁

轻量级锁\`的获取

* 线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word。
* 然后线程尝试使用`CAS`将对象头中的Mark Word替换为指向锁记录的指针。
* 如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。

`轻量级锁`的撤销

* 使用原子的`CAS`操作将Displaced Mark Word替换回到对象头。
* 如果成功，则表示没有竞争发生。
* 如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。
  * 因为自旋会消耗CPU，为了避免无用的自旋，比如获得锁的线程被阻塞住了，一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。

### 锁的比较

| 锁类型 | 优点 | 缺点 | 适用场景 |
| :--- | :--- | :--- | :--- |
| `偏向锁` | 加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在毫秒级差距 | 如线程间存在竞争，会带来额外撤销锁带来的消耗 | 适用仅有一个线程访问的同步块 |
| `轻量级锁` | 竞争的线程不会阻塞，提高了程序相应速度 | 如果始终得不到锁的线程，自旋消耗大量CPU资源 | 追求相应时间，同步块执行时间较短 |
| `重量级锁` | 线程竞争不使用自旋，不会消耗CPU | 线程阻塞，响应时间长 | 追求吞吐量，同步块执行时间较长 |



