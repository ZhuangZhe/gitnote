# volatile关键字

`volatile`就可以说是Java虚拟机提供的最轻量级的同步机制。

针对`volatile`修饰的变量给Java虚拟机特殊的约定，线程对`volatile`变量的修改会立刻被其他线程所感知，即不会出现数据脏读的现象，从而保证数据的“可见性”。

## volatile实现原理

在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出`Lock`前缀的指令，`Lock`前缀的指令在多核处理器下：

* 将当前处理器缓存行的数据写回系统内存。
* 这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效。

为了提高处理速度，处理器不直接和内存进行通信，而是先将系统内存的数据读到内部缓存\(L1，L2或其他\)后再进行操作，但操作完之后会写到内存。如果对声明了`volatile`的变量进行写操作，JVM就会向处理器发送一条`Lock`前缀的指令，将这个变量所在缓存行的数据写回到系统内存。

但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

总结：

* `Lock`前缀的指令会引起处理器缓存写回内存。
* 一个处理器的缓存回写到内存会导致其他处理器的缓存失效。
* 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。

## volatile的内存语义

假设线程A先执行writer方法，线程B随后执行reader方法，初始时线程的本地内存中flag和a都是初始状态。

线程A执行volatile写后，线程中本地内存中共享变量就会置为失效的状态，因此线程B再需要读取从主内存中去读取该变量的最新值。

### volatile的内存语义实现

想阻止重排序，可以添加内存屏障，J ava编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。

内存屏障种类：

* `StoreStore`屏障：禁止上面的普通写和下面的`volatile`写重排序；
* `StoreLoad`屏障：防止上面的`volatile`写与下面可能有的`volatile`读/写重排序
* `LoadLoad`屏障：禁止下面所有的普通读操作和上面的`volatile`读重排序
* `LoadStore`屏障：禁止下面所有的普通写操作和上面的`volatile`读重排序

JMM插入内存屏障的策略：

* 在每个`volatile`写操作的前面插入一个`StoreStore`屏障；
* 在每个`volatile`写操作的后面插入一个`StoreLoad`屏障；
* 在每个`volatile`读操作的后面插入一个`LoadLoad`屏障；
* 在每个`volatile`读操作的后面插入一个`LoadStore`屏障。

`volatile`写是在前面和后面分别插入内存屏障，而`volatile`读操作是在后面插入两个内存屏障

